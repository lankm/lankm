class Translation # translation using global basis vectors
  pri pos # position of last update
  pri vel # velocity
  pri time # time of last update

  pri cur_pos(cur_time) # pos + dt*vel
  pri update(cur_time) # pos -> cur_pos(). time -> cur_time
  pub accelerate(vel_diff, cur_time) # update(). vel += vel_diff
  pub cur_pos_diff(other, cur_time) # other.cur_pos() - cur_pos()
  pub cur_vel_diff(other, cur_time) # other.vel - vel

class Rotation # rotation using global basis vectors
  pri ori # orientation of last update
  pub rot # rotation vector
  pub vel # angular velocity
  pri time # time of last update

  pri cur_ori(cur_time) # left multiply quaternions. (cos(),sin()*rot)*ori
  pri update(cur_time) # ori = cur_ori()
  pub accelerate(rot, vel_diff, cur_time) # update(). update rot and vel [TODO learn]
  pub cur_ori_diff(other, cur_time) # other.cur_ori()*cur_ori().inv() [TODO double check]

class Pose # pose using relative basis vectors
  pri trans # translation object
  pri rot # rotation object

  pub cur_pos_diff(other, cur_time) # passthrough. uses rot to change basis [TODO details]
  pub cur_vel_diff(other, cur_time) # passthrough. uses rot to change basis [TODO details]
  pub trans_accelerate(vel_diff, cur_time) # uses rot to change basis. passthrough [TODO details]
  pub cur_ori_diff(other, cur_time) # rot.cur_ori().inv()*other.rot.cur_ori() [TODO double check]
  pub rot_accelerate(vel_diff, cur_time) # uses rot to change basis. passthrough [TODO details]

class Entity # applies relative forces. pose.trans.cur_pos() is the center of mass.
  pri pose # pose object
  pri mass # inertial mass
  pri moi # moment of inertia

  [TODO continue]

===============================================================================
class XYZ
  pri v
class Versor
  pri q

  pub rotate(xyz): XYZ
    # q * xyz * q.inv()
  pub inv(): Versor
    # negate i j k

class Pose
  pri glob_time

  pri glob_pos
  pri glob_pos_vel

  pri glob_ori
  pri glob_rot_axis
  pri glob_rot_vel

  pri glob_cur_pos(time): VectorQuaternion
    # result = pos + dt*vel
  pri glob_cur_ori(glob_time): Versor
    # rot = <cos(dt*vel), sin(dt*vel)*axis>
    # result = rot*ori
  pri update(time): void
    # glob_pos = cur_glob_pos(time)
    # glob_ori = cur_glob_ori(time)
    # glob_time = time
  
  pri glob_pos_diff(other, time): VectorQuaternion
    # result = other.cur_glob_pos(time) - cur_glob_pos(time)
  pri glob_vel_diff(other, time): VectorQuaternion
    # result = other.glob_pos_vel - glob_pos_vel

  pub rel_pos(other, time): VectorQuaternion
    # glob_pos_diff = glob_pos_diff(other, time)
    # glob_cur_ori = glob_cur_ori(other, time).inv()
    # result = glob_cur_ori.rotate(glob_pos_diff)
  pub rel_ori(other, time): Versor

  pub rel_vel(other, time): pos_vel
    # calculate difference in velocity
    # convert global basis to relative basis

